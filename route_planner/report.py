from __future__ import annotations

from html.parser import HTMLParser
from importlib.resources import open_text as open_text_resource
from math import ceil
from os import linesep
from typing import Optional

from . import styles
from .action import Error, Metrics, State
from .route import DamageTable, Enemy, Hit, HitType, Route, RouteData


class ConvertMinifiedToPrettyHtmlParser(HTMLParser):
    """
    A custom HTML parser to convert minified HTML to pretty-printed HTML.
    Handles specific tags in a unique manner for better readability.  Does not
    have error handling, and does not support malformed HTML.  Only intended
    to be suitable for usage on the reports generated by this project.
    """

    SINGLE_LINE_TAGS = ["tr", "li", "span", "title"]
    EMPTY_TAGS = ["br"]

    def __init__(self) -> None:
        super().__init__()
        self._indent_level: int = 0
        self._single_line_tag_stack: list[str] = []
        self._pretty_html_parts: list[str] = []

    def _indent_str(self) -> str:
        return "    " * self._indent_level

    def handle_starttag(
        self, tag: str, attrs: list[tuple[str, Optional[str]]]
    ) -> None:
        attrs_str = "".join(
            f' {name}="{value}"' if value is not None else f" {name}"
            for name, value in attrs
        )
        if self._single_line_tag_stack:
            self._pretty_html_parts.append(f"<{tag}{attrs_str}")
        else:
            self._pretty_html_parts.append(
                (linesep if self._pretty_html_parts else "")
                + self._indent_str()
                + f"<{tag}{attrs_str}"
            )
        if tag in ConvertMinifiedToPrettyHtmlParser.SINGLE_LINE_TAGS:
            self._single_line_tag_stack.append(tag)
        if tag not in ConvertMinifiedToPrettyHtmlParser.EMPTY_TAGS:
            self._pretty_html_parts.append(">")  # terminate normally
            self._indent_level += 1
        else:
            self._pretty_html_parts.append("/>")  # self-close empty tags

    def handle_endtag(self, tag: str) -> None:
        if tag in ConvertMinifiedToPrettyHtmlParser.EMPTY_TAGS:
            return  # empty tags self-close in handle_starttag
        self._indent_level -= 1
        if self._single_line_tag_stack:
            self._pretty_html_parts.append(f"</{tag}>")
            if tag == self._single_line_tag_stack[-1]:
                self._single_line_tag_stack.pop()
        else:
            self._pretty_html_parts.append(
                linesep + self._indent_str() + f"</{tag}>"
            )

    def handle_data(self, data: str) -> None:
        if self._single_line_tag_stack:
            self._pretty_html_parts.append(data)
        else:
            for line in data.splitlines():
                self._pretty_html_parts.append(
                    linesep + self._indent_str() + line
                )

    def pretty_html(self) -> str:
        return "".join(self._pretty_html_parts)


def convert_minified_to_pretty_html(content: str) -> str:
    parser = ConvertMinifiedToPrettyHtmlParser()
    parser.feed(content)
    return parser.pretty_html()


def page(body: str, *, title: str = "", style: str = "light") -> str:
    if title:
        title = f"<title>{title}</title>"
    if style:
        with open_text_resource(styles, f"{style}.css") as css:
            style = f"<style>{css.read()}</style>"
    content = f"<html><head>{title}{style}</head><body>{body}</body></html>"
    return convert_minified_to_pretty_html(content)


def damage_table(
    table: DamageTable,
    *,
    hit_lookup: Optional[dict[str, dict[Enemy, dict[HitType, Hit]]]],
) -> str:
    if not hit_lookup:
        hit_lookup = {}
    html: list[str] = []
    html.append('<table class="route"><thead><tr>')
    for hit_type in table.hit_types:
        html.append(
            f'<th colspan="2" title="{hit_type.info.display_name}">'
            f"{hit_type.info.column_name}</th>"
        )
    html.append('<th title="Enemy">Enemy</th></tr></thead><tbody>')

    for enemy in table.enemies:
        for form_name, health in enemy.info.form_health_lookup.items():
            html.append("<tr>")
            for hit_type in table.hit_types:
                hit: Hit = (
                    hit_lookup.get(table.weapon, {})
                    .get(enemy, {})
                    .get(hit_type, Hit())
                )
                td_classes: list[str] = [hit_type.name.lower()]
                hit_display = hit_type.info.display_name.lower()
                hit_cells: list[tuple[int, str, list[str]]] = [
                    (hit.damage, "hits", []),
                    (hit.with_rtsr, "hits with RTSR", ["rtsr"]),
                ]
                for damage, hit_text, extra_classes in hit_cells:
                    html.append(  # partial tag
                        f'<td class="{" ".join(td_classes + extra_classes)}"'
                    )
                    if damage:
                        hits = ceil(health / damage)
                        title = f"{hits} {hit_display} {hit_text} for {damage}"
                        html.append(
                            f' title="{title}">{hits}</td>'
                        )  # rest of tag
                    else:
                        html.append("></td>")  # rest of tag
            html.append(
                f'<td class="enemy" title="{health} total hp">'
                f"{form_name}</td></tr>"
            )
    html.append("</tbody></table>")
    return "".join(html)


def notes_list(route_data: RouteData) -> str:
    if not route_data.notes:
        return ""
    return (
        '<ul class="route notes">'
        + "".join([f"<li>{note}</li>" for note in route_data.notes])
        + "</ul>"
    )


def _value_cell(name: str, old_value: int, new_value: int) -> str:
    css_class = name.lower().replace(" ", "_")
    html = f'<td class="{css_class}" title="{new_value} {name.lower()}">'
    if new_value != old_value:
        change = new_value - old_value
        change_class = "subtract" if change < 0 else "add"
        html += f'<span class="{change_class}">{change:+}</span>'
        html += f"<br/>{new_value}"
    html += "</td>"
    return html


def steps_table(route_data: RouteData) -> str:
    region_count = 0
    last_metrics = Metrics()
    region = ""
    columns = [
        ("Souls", "Souls"),
        ("Item Souls", "‚òÑÔ∏è"),
        ("Homeward Bones", "ü¶¥"),
        ("Titanite Shards", "üåë"),
        ("Twinkling Titanite", "üíé"),
        ("Item Humanities", "üë§"),
        ("Humanity", "üë®"),
        ("Action", "Action"),
    ]

    html: list[str] = []
    html.append('<table class="route"><thead><tr>')
    html.extend(
        [f'<th title="{column[0]}">{column[1]}</th>' for column in columns]
    )
    html.append("</tr></thead><tbody>")
    for event in route_data.events:
        if event.action.output:  # only output rows that should be
            rowclass = ""
            if isinstance(event.action, Error):
                rowclass = "error"
            elif event.action.optional:
                rowclass = "optional"
            html.append(
                (f'<tr class="{rowclass}">' if rowclass else "<tr>")
                + _value_cell("Souls", last_metrics.souls, event.metrics.souls)
                + _value_cell(
                    "Item Souls",
                    last_metrics.item_souls,
                    event.metrics.item_souls,
                )
                + _value_cell(
                    "Homeward Bones",
                    last_metrics.homeward_bones,
                    event.metrics.homeward_bones,
                )
                + _value_cell(
                    "Titanite Shards",
                    last_metrics.titanite_shards,
                    event.metrics.titanite_shards,
                )
                + _value_cell(
                    "Twinkling Titanite",
                    last_metrics.twinkling_titanite,
                    event.metrics.twinkling_titanite,
                )
                + _value_cell(
                    "Item Humanities",
                    last_metrics.item_humanities,
                    event.metrics.item_humanities,
                )
                + _value_cell(
                    "Humanity", last_metrics.humanity, event.metrics.humanity
                )
                + '<td class="action">'
                f'<span class="name">{event.action.name}</span>'
                f' <span class="display">{event.action.display}</span>'
                f'<br/><span class="detail">{event.action.detail}'
                "</span></td></tr>"
            )
        if event.metrics.region != region:
            region = event.metrics.region
            region_count += 1
            html.append(
                "</tbody><tbody><tr>"
                f'<td colspan="{len(columns)}" class="region">'
                f"{region_count:02}. {region}</td></tr>"
                "</tbody><tbody>"
            )
        last_metrics = event.metrics
    html.append("</tbody></table>")

    if event.metrics.error_count:
        html.insert(  # prepend
            0,
            (
                f'<span class="warning">{event.metrics.error_count}'
                " errors present.</span>"
            ),
        )
    return "".join(html)


def route(
    route: Route,
    *,
    damage_tables: Optional[list[DamageTable]] = None,
    hit_lookup: Optional[dict[str, dict[Enemy, dict[HitType, Hit]]]] = None,
) -> str:
    html: list[str] = []
    if route.name:
        html.append(f'<span class="route display_name">{route.name}</span>')
    if not route.segment.condition:
        html.append('<span class="warning">Route Segment is DISABLED</span>')
    else:
        route_data = route.run(State())
        if route_data.notes:
            html.append('<span class="route section">Notes</span>')
            html.append(notes_list(route_data))

        for table in route.damage_tables:
            html.append(
                f'<span class="route section">Hits ({table.weapon})</span>'
            )
            html.append(damage_table(table, hit_lookup=route.hit_lookup))
        html.append('<span class="route section">Steps</span>')
        html.append(steps_table(route_data))
    return "".join(html)
